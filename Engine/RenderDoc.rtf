{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang3082{\fonttbl{\f0\fnil Consolas;}{\f1\fnil\fcharset0 Calibri;}}
{\colortbl ;\red128\green128\blue128;\red0\green0\blue0;\red111\green0\blue138;\red163\green21\blue21;\red0\green0\blue255;\red43\green145\blue175;\red0\green128\blue0;}
{\*\generator Riched20 10.0.15063}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\cf1\f0\fs19\lang10 #ifndef\cf2  _MODULE_RENDER_3D_H_\par
\cf1 #define\cf2  \cf3 _MODULE_RENDER_3D_H_\cf2\par
\par
\cf1 #include\cf2  \cf4 "Module.h"\cf2\par
\cf1 #include\cf2  \cf4 "Globals.h"\cf2\par
\cf1 #include\cf2  \cf4 "glmath.h"\cf2\par
\cf1 #include\cf2  \cf4 "Light.h"\cf2\par
\cf1 #include\cf2  \cf4 "MathGeoLib/MathGeoLib.h"\cf2\par
\par
\cf1 #define\cf2  \cf3 MAX_LIGHTS\cf2  8\par
\cf1 #define\cf2  \cf3 CHECKERS_HEIGHT\cf2  256\par
\cf1 #define\cf2  \cf3 CHECKERS_WIDTH\cf2  256\par
\par
\cf5 class\cf2  \cf6 ModuleRenderer3D\cf2  : \cf5 public\cf2  \cf6 Module\cf2\par
\{\par
\cf5 public\cf2 :\par
\par
\tab ModuleRenderer3D(\cf5 const\cf2  \cf5 char\cf2 * \cf1 _name\cf2 , \cf6 MODULE_ID\cf2  \cf1 _id\cf2 , \cf5 bool\cf2  \cf1 _config_menu\cf2 , \cf5 bool\cf2  \cf1 _enabled\cf2  = \cf5 true\cf2 );\par
\tab ~ModuleRenderer3D();\par
\par
\cf5 public\cf2 :\par
\par
\tab\cf5 bool\cf2\tab\tab\tab Awake(\cf5 const\cf2  \cf6 JSON_Object\cf2 * \cf1 data_root\cf2 )\cf5 final\cf2 ;\par
\tab\cf5 bool\cf2\tab\tab\tab Init() \cf5 final\cf2 ;\par
\tab\cf6 update_status\cf2\tab PreUpdate(\cf5 float\cf2  \cf1 dt\cf2 ) \cf5 final\cf2 ;\par
\tab\cf6 update_status\cf2\tab Update(\cf5 float\cf2  \cf1 dt\cf2 )\cf5 final\cf2 ;\par
\tab\cf6 update_status\cf2\tab PostUpdate(\cf5 float\cf2  \cf1 dt\cf2 ) \cf5 final\cf2 ;\par
\tab\cf5 bool\cf2\tab\tab\tab CleanUp() \cf5 final\cf2 ;\par
\tab\cf5 void\cf2\tab\tab\tab BlitConfigInfo()\cf5 final\cf2 ;\par
\tab\cf5 void\cf2\tab\tab\tab SaveConfigInfo(\cf6 JSON_Object\cf2 * \cf1 data_root\cf2 );\par
\par
\cf5 private\cf2 :\par
\par
\tab\cf5 bool\cf2\tab vsync = \cf5 false\cf2 ;\par
\tab\cf5 bool\cf2\tab depth_test = \cf5 false\cf2 ;\par
\tab\cf5 bool\cf2\tab cull_face = \cf5 false\cf2 ;\par
\tab\cf5 bool\cf2\tab texture_2d = \cf5 false\cf2 ;\par
\tab\cf5 bool\cf2\tab dither = \cf5 false\cf2 ;\par
\tab\cf5 bool\cf2\tab wireframe = \cf5 false\cf2 ;\par
\tab\cf5 bool\cf2\tab front_wireframe = \cf5 false\cf2 ;\par
\par
\tab\cf5 bool\cf2\tab lighting = \cf5 false\cf2 ;\par
\tab\cf5 float\cf2\tab lighting_color[4];\par
\par
\tab\cf5 bool\cf2\tab material_color = \cf5 false\cf2 ;\par
\tab\cf5 float\cf2\tab material_ambient[4];\par
\tab\cf5 float\cf2\tab material_diffuse[4];\par
\par
\tab\cf5 bool\cf2\tab fog = \cf5 false\cf2 ;\par
\tab\cf5 float\cf2\tab fog_density = 0.0f;\par
\tab\cf5 float\cf2\tab fog_color[4];\par
\par
\tab\cf5 bool\cf2\tab custom_clear = \cf5 false\cf2 ;\par
\tab\cf5 float\cf2\tab clear_color[4];\par
\tab\cf5 float\cf2\tab clear_depth = 0.0f;\par
\par
\cf5 private\cf2 :\par
\par
\tab\cf6 Light\cf2\tab\tab\tab lights[\cf3 MAX_LIGHTS\cf2 ];\par
\tab\cf6 SDL_GLContext\cf2\tab context;\par
\tab\cf6 mat3x3\cf2\tab\tab\tab NormalMatrix;\par
\tab\cf6 mat4x4\cf2\tab\tab\tab ModelMatrix, ViewMatrix, ProjectionMatrix;\par
\par
\cf5 public\cf2 :\par
\par
\tab\cf5 void\cf2  OnResize(\cf5 int\cf2  \cf1 width\cf2 , \cf5 int\cf2  \cf1 height\cf2 );\par
\tab\cf5 bool\cf2  GetWireframe() \cf5 const\cf2 ;\par
\tab\cf5 bool\cf2  GetWireframeFront() \cf5 const\cf2 ;\par
\tab\cf5 void\cf2  DisableGLRenderFlags();\par
\tab\cf5 void\cf2  EnableGLRenderFlags();\par
\par
\tab\cf5 unsigned\cf2  \cf5 char\cf2   checkImage[\cf3 CHECKERS_HEIGHT\cf2 ][\cf3 CHECKERS_WIDTH\cf2 ][4];\par
\tab\cf6 uint\cf2  ImageName = 0;\par
\};\par
\par
\par
\cf1 #endif\cf2  \cf7 // !_MODULE_RENDER_3D_H_\cf2\par
\par
\par
\cf0\f1\fs22 // -----------------------------------------------------------------------\par
\par
#include "Globals.h"\par
#include "Application.h"\par
#include "GeometryManager.h"\par
#include "ModuleRenderer3D.h"\par
#include "Glew/include/glew.h"\par
#include "SDL/include/SDL_opengl.h"\par
#include <gl/GL.h>\par
#include <gl/GLU.h>\par
#include "ModuleWindow.h"\par
#include "ModuleCamera3D.h"\par
#include "FileSystem.h"\par
#include "ModuleAudio.h"\par
#include "ModuleImgui.h"\par
\par
#pragma comment (lib, "glu32.lib")    /* link OpenGL Utility lib     */\par
#pragma comment (lib, "opengl32.lib") /* link Microsoft OpenGL lib   */\par
#pragma comment (lib, "Engine/Glew/lib/Win32/glew32.lib")\par
\par
// Constructors =================================\par
ModuleRenderer3D::ModuleRenderer3D(const char* _name, MODULE_ID _id, bool _config_menu, bool _enabled) : Module(_name, _id, _config_menu, _enabled)\par
\{\par
\par
\}\par
\par
// Destructors ==================================\par
ModuleRenderer3D::~ModuleRenderer3D()\par
\{\par
\par
\}\par
\par
// Game Loop ====================================\par
bool ModuleRenderer3D::Awake(const JSON_Object * data_root)\par
\{\par
\tab vsync = json_object_get_boolean(data_root, "vsync");\par
\tab\par
\tab depth_test = json_object_get_boolean(data_root, "depth_test");\par
\tab\par
\tab cull_face = json_object_get_boolean(data_root, "cull_face");\par
\tab\par
\tab texture_2d = json_object_get_boolean(data_root, "texture_2d");\par
\tab\par
\tab dither = json_object_get_boolean(data_root, "dither");\par
\par
\tab wireframe = json_object_get_boolean(data_root, "wireframe");\par
\par
\tab front_wireframe = json_object_get_boolean(data_root, "front_wireframe");\par
\par
\tab lighting = json_object_get_boolean(data_root, "lighting");\par
\tab JSON_Array* lighting_color_array = json_object_get_array(data_root, "lighting_color");\par
\tab lighting_color[0] = json_array_get_number(lighting_color_array, 0);\par
\tab lighting_color[1] = json_array_get_number(lighting_color_array, 1);\par
\tab lighting_color[2] = json_array_get_number(lighting_color_array, 2);\par
\tab lighting_color[3] = json_array_get_number(lighting_color_array, 3);\par
\tab\par
\tab material_color = json_object_get_boolean(data_root, "material_color");\par
\tab JSON_Array* material_ambient_array = json_object_get_array(data_root, "material_ambient");\par
\tab material_ambient[0] = json_array_get_number(material_ambient_array, 0);\par
\tab material_ambient[1] = json_array_get_number(material_ambient_array, 1);\par
\tab material_ambient[2] = json_array_get_number(material_ambient_array, 2);\par
\tab material_ambient[3] = json_array_get_number(material_ambient_array, 3);\par
\tab JSON_Array* material_diffuse_array = json_object_get_array(data_root, "material_diffuse");\par
\tab material_diffuse[0] = json_array_get_number(material_diffuse_array, 0);\par
\tab material_diffuse[1] = json_array_get_number(material_diffuse_array, 1);\par
\tab material_diffuse[2] = json_array_get_number(material_diffuse_array, 2);\par
\tab material_diffuse[3] = json_array_get_number(material_diffuse_array, 3);\par
\tab\par
\tab fog = json_object_get_boolean(data_root, "fog");\par
\tab fog_density = json_object_get_number(data_root, "fog_density");\par
\tab JSON_Array* fog_color_array = json_object_get_array(data_root, "fog_color");\par
\tab fog_color[0] = json_array_get_number(fog_color_array, 0);\par
\tab fog_color[1] = json_array_get_number(fog_color_array, 1);\par
\tab fog_color[2] = json_array_get_number(fog_color_array, 2);\par
\tab fog_color[3] = json_array_get_number(fog_color_array, 3);\par
\par
\tab custom_clear = json_object_get_boolean(data_root, "custom_clear");\par
\tab JSON_Array* clear_color_array = json_object_get_array(data_root, "clear_color");\par
\tab clear_color[0] = json_array_get_number(clear_color_array, 0);\par
\tab clear_color[1] = json_array_get_number(clear_color_array, 1);\par
\tab clear_color[2] = json_array_get_number(clear_color_array, 2);\par
\tab clear_color[3] = json_array_get_number(clear_color_array, 3);\par
\tab clear_depth = json_object_get_number(data_root, "clear_depth");\par
\tab\par
\tab config_menu = true;\par
\par
\tab return true;\par
\}\par
\par
// Called before render is available\par
bool ModuleRenderer3D::Init()\par
\{\par
\tab LOG("Creating 3D Renderer context");\par
\tab bool ret = true;\par
\tab\par
\tab\par
\tab //OPENGL initialization\par
\tab //Create context\par
\tab context = SDL_GL_CreateContext(App->window->window);\par
\tab if(context == NULL)\par
\tab\{\par
\tab\tab LOG("[error] OpenGL context could not be created! SDL_Error: %s\\n", SDL_GetError());\par
\tab\tab ret = false;\par
\tab\}\par
\par
\tab GLenum glew_error = glewInit();\par
\tab if (glew_error != GL_NO_ERROR)\par
\tab\{\par
\tab\tab LOG("[error]Error initializing GLew! %s\\n", glewGetErrorString(glew_error));\par
\tab\}\par
\tab else\par
\tab\{\par
\tab\tab LOG("Using GLew: %s", glewGetString(GLEW_VERSION));\par
\tab\}\par
\par
\tab if(ret == true)\par
\tab\{\par
\tab\tab //Use Vsync\par
\tab\tab if (vsync && SDL_GL_SetSwapInterval(1) < 0)\par
\tab\tab\{\par
\tab\tab\tab LOG("[error] Unable to set VSync! SDL Error: %s\\n", SDL_GetError());\par
\tab\tab\}\par
\tab\tab else if(!vsync)\par
\tab\tab\{\par
\tab\tab\tab SDL_GL_SetSwapInterval(0);\par
\tab\tab\}\par
\par
\tab\tab //Initialize Projection Matrix\par
\tab\tab glMatrixMode(GL_PROJECTION);\par
\tab\tab glLoadIdentity();\par
\par
\tab\tab //Check for error\par
\tab\tab GLenum error = glGetError();\par
\tab\tab if(error != GL_NO_ERROR)\par
\tab\tab\{\par
\tab\tab\tab LOG("[error] Error initializing OpenGL! %s\\n", gluErrorString(error));\par
\tab\tab\tab ret = false;\par
\tab\tab\}\par
\par
\tab\tab //Initialize Model view Matrix\par
\tab\tab glMatrixMode(GL_MODELVIEW);\par
\tab\tab glLoadIdentity();\par
\par
\tab\tab //Check for error\par
\tab\tab error = glGetError();\par
\tab\tab if(error != GL_NO_ERROR)\par
\tab\tab\{\par
\tab\tab\tab LOG("[error] Error initializing OpenGL! %s\\n", gluErrorString(error));\par
\tab\tab\tab ret = false;\par
\tab\tab\}\par
\tab\tab\par
\tab\tab glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);\par
\tab\tab\tab\tab\par
\tab\tab //Initialize clear color\par
\tab\tab if (custom_clear)\par
\tab\tab\{\par
\tab\tab\tab glClearColor(clear_color[0], clear_color[1], clear_color[2], clear_color[3]);\par
\tab\tab\tab glClearDepth(clear_depth);\par
\tab\tab\}\par
\tab\tab else\par
\tab\tab\{\par
\tab\tab\tab glClearColor(0.0, 0.0, 0.0, 0.0);\par
\tab\tab\tab glClearDepth(1.0f);\par
\tab\tab\}\par
\par
\tab\tab glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\par
\par
\tab\tab //Enable OpenGL Options\par
\tab\tab if (depth_test)\par
\tab\tab\{\par
\tab\tab\tab glEnable(GL_DEPTH_TEST);\par
\tab\tab\}\par
\par
\tab\tab if (cull_face)\par
\tab\tab\{\par
\tab\tab\tab glEnable(GL_CULL_FACE);\par
\tab\tab\}\par
\par
\tab\tab if (texture_2d)\par
\tab\tab\{\par
\tab\tab\tab glEnable(GL_TEXTURE_2D);\par
\tab\tab\}\par
\par
\tab\tab if (dither)\par
\tab\tab\{\par
\tab\tab\tab glEnable(GL_DITHER);\par
\tab\tab\}\par
\par
\tab\tab //Initialize lighting states\par
\tab\tab if (lighting)glEnable(GL_LIGHTING);\par
\tab\tab GLfloat l_color[] = \{ lighting_color[0], lighting_color[1], lighting_color[2], lighting_color[3] \};\par
\tab\tab glLightModelfv(GL_EMISSION, l_color);\par
\par
\tab\tab //Initialize material states\par
\tab\tab if (material_color)\par
\tab\tab\{\par
\tab\tab\tab glEnable(GL_COLOR_MATERIAL);\par
\tab\tab\}\par
\tab\tab GLfloat m_ambient[] = \{ material_ambient[0], material_ambient[1], material_ambient[2], material_ambient[3] \};\par
\tab\tab glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, m_ambient);\par
\tab\tab GLfloat m_diffuse[] = \{ material_diffuse[0], material_diffuse[1], material_diffuse[2], material_diffuse[3] \};\par
\tab\tab glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, m_diffuse);\par
\tab\tab\par
\tab\tab //Initialize fog states\par
\tab\tab if (fog)\par
\tab\tab\{\par
\tab\tab\tab glEnable(GL_FOG);\par
\tab\tab\}\par
\tab\tab const GLfloat f_color[4] = \{ fog_color[0], fog_color[1], fog_color[2], fog_color[3] \};\par
\tab\tab glFogfv(GL_FOG_COLOR, f_color);\par
\tab\tab glFogf(GL_FOG_DENSITY, fog_density);\par
\tab\tab\par
\tab\tab //Initialize default light\par
\tab\tab lights[0].ref = GL_LIGHT0;\par
\tab\tab lights[0].ambient.Set(0.25f, 0.25f, 0.25f, 1.0f);\par
\tab\tab lights[0].diffuse.Set(0.75f, 0.75f, 0.75f, 1.0f);\par
\tab\tab lights[0].SetPos(0.0f, 0.0f, 2.5f);\par
\tab\tab lights[0].Init();\par
\tab\tab\tab\par
\tab\tab lights[0].Active(true);\par
\tab\par
\tab\}\par
\par
\tab // Projection matrix for\par
\tab OnResize(SCREEN_WIDTH, SCREEN_HEIGHT);\par
\tab\par
\par
\par
\par
\tab for (int i = 0; i < CHECKERS_HEIGHT; i++) \{\par
\tab\tab for (int j = 0; j < CHECKERS_WIDTH; j++) \{\par
\tab\tab\tab int c = ((((i & 0x8) == 0) ^ (((j & 0x8)) == 0))) * 255;\par
\tab\tab\tab checkImage[i][j][0] = (GLubyte)c;\par
\tab\tab\tab checkImage[i][j][1] = (GLubyte)c;\par
\tab\tab\tab checkImage[i][j][2] = (GLubyte)c;\par
\tab\tab\tab checkImage[i][j][3] = (GLubyte)255;\par
\tab\tab\}\par
\tab\}\par
\par
\tab glPixelStorei(GL_UNPACK_ALIGNMENT, 1);\par
\tab glGenTextures(1, &ImageName);\par
\tab glBindTexture(GL_TEXTURE_2D, ImageName);\par
\tab glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\par
\tab glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\par
\tab glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\par
\tab glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\par
\tab glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, CHECKERS_WIDTH, CHECKERS_HEIGHT,0, GL_RGBA, GL_UNSIGNED_BYTE, checkImage);\par
\par
\tab glEnable(GL_TEXTURE_2D);\par
\par
\tab return ret;\par
\}\par
\par
// PreUpdate: clear buffer\par
update_status ModuleRenderer3D::PreUpdate(float dt)\par
\{\par
\tab glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\par
\tab glLoadIdentity();\par
\par
\tab glMatrixMode(GL_MODELVIEW);\par
\tab glLoadMatrixf(App->camera->GetViewMatrix());\par
\par
\tab // light 0 on cam pos\par
\tab lights[0].SetPos(App->camera->position.x, App->camera->position.y, App->camera->position.z);\par
\par
\tab for (uint i = 0; i < MAX_LIGHTS; ++i)\par
\tab\{\par
\tab\tab lights[i].Render();\par
\tab\}\par
\par
\tab return UPDATE_CONTINUE;\par
\}\par
\par
update_status ModuleRenderer3D::Update(float dt)\par
\{\par
\tab //Info Source\par
\tab //http://www.pascalgamedevelopment.com/showthread.php?6617-drawing-3d-geometrical-shapes-using-opengl-but-without-glu\par
\par
\par
\tab /*float NumMajor = 10;\par
\tab float NumMinor = 6;\par
\tab float MinorRadius = 2, MajorRadius = 4;\par
\tab float MajorStep, MinorStep;\par
\tab int i, j;\par
\tab float a0, a1, b;\par
\tab float x0, y0, x1, y1, c, r, z;\par
\tab MajorStep = 2.7 * HAVE_M_PI / NumMajor;\par
\tab MinorStep = 2.7 * HAVE_M_PI / NumMajor;\par
\tab for (i = 0; i < NumMajor; i++)\par
\tab\{\par
\tab\tab a0 = i * MajorStep;\par
\tab\tab a1 = a0 + MajorStep;\par
\tab\tab x0 = cos(a0);\par
\tab\tab y0 = sin(a0);\par
\tab\tab x1 = cos(a1);\par
\tab\tab y1 = sin(a1);\par
\tab\tab glBegin(GL_TRIANGLE_STRIP);\par
\tab\tab for (j = 0; j < NumMinor; j++)\par
\tab\tab\{\par
\par
\tab\tab\tab b = j * MinorStep;\par
\tab\tab\tab c = cos(b);\par
\tab\tab\tab r = MinorRadius * c + MajorRadius;\par
\tab\tab\tab z = MinorRadius * sin(b);\par
\par
\tab\tab\tab glNormal3f(x0 * c, y0 * c, z / MinorRadius);\par
\tab\tab\tab glTexCoord2f(i / NumMajor, j / NumMinor);\par
\tab\tab\tab glVertex3f(x0 * r, y0 * r, z);\par
\par
\tab\tab\tab glNormal3f(x1 * c, y1 * c, z / MinorRadius);\par
\tab\tab\tab glTexCoord2f((i + 1) / NumMajor, j / NumMinor);\par
\tab\tab\tab glVertex3f(x1 * r, y1 * r, z);\par
\tab\tab\}\par
\tab\tab glEnd();\par
\tab\}*/\par
\par
\tab GLfloat v0[3] = \{ 1,1,0 \};\par
\tab GLfloat v1[3] = \{ 0,1,0 \};\par
\tab GLfloat v2[3] = \{ 0,0,0 \};\par
\tab GLfloat v3[3] = \{ 1,0,0 \};\par
\tab GLfloat v4[3] = \{ 1,0,1 \};\par
\tab GLfloat v5[3] = \{ 1,1,1 \};\par
\tab GLfloat v6[3] = \{ 0,1,1 \};\par
\tab GLfloat v7[3] = \{ 0,0,1 \};\par
\par
\tab glBindTexture(GL_TEXTURE_2D, ImageName);\par
\par
\tab glBegin(GL_TRIANGLES);  // draw a cube with 12 triangles\par
\tab\par
\tab // front face =================\par
\tab glVertex3fv(v0);\par
\tab glTexCoord2f(1.0f, 0.0f);\par
\tab glVertex3fv(v1);\par
\tab glTexCoord2f(0.0f, 0.0f);\par
\tab glVertex3fv(v2);\par
\tab glTexCoord2f(0.0f, 1.0f);\par
\par
\par
\tab glVertex3fv(v2);\par
\tab glTexCoord2f(0.0f, 1.0f);\par
\tab glVertex3fv(v3);\par
\tab glTexCoord2f(1.0f, 1.0f);\par
\tab glVertex3fv(v0);\par
\tab glTexCoord2f(1.0f, 0.0f);\par
\par
\par
\par
\tab // back face ==================\par
\tab glVertex3fv(v5);\par
\tab glTexCoord2f(0.0f, 0.0f);\par
\tab glVertex3fv(v6);\par
\tab glTexCoord2f(1.0f, 0.0f);\par
\tab glVertex3fv(v7);\par
\tab glTexCoord2f(1.0f, 1.0f);\par
\par
\tab glVertex3fv(v5);\par
\tab glTexCoord2f(0.0f, 0.0f);\par
\tab glVertex3fv(v4);\par
\tab glTexCoord2f(0.0f, 1.0f);\par
\tab glVertex3fv(v7);\par
\tab glTexCoord2f(1.0f, 1.0f);\par
\par
\par
\tab // right face =================\par
\tab glVertex3fv(v4);\par
\tab glTexCoord2f(1.0f, 1.0f);\par
\tab glVertex3fv(v3);\par
\tab glTexCoord2f(0.0f, 1.0f);\par
\tab glVertex3fv(v0);\par
\tab glTexCoord2f(0.0f, 0.0f);\par
\par
\tab glVertex3fv(v0);\par
\tab glTexCoord2f(0.0f, 0.0f);\par
\tab glVertex3fv(v5);\par
\tab glTexCoord2f(1.0f, 0.0f);\par
\tab glVertex3fv(v4);\par
\tab glTexCoord2f(1.0f, 1.0f);\par
\par
\tab // left face ==================\par
\tab glVertex3fv(v1);\par
\tab glTexCoord2f(1.0f, 0.0f);\par
\tab glVertex3fv(v2);\par
\tab glTexCoord2f(1.0f, 1.0f);\par
\tab glVertex3fv(v7);\par
\tab glTexCoord2f(0.0f, 1.0f);\par
\par
\tab glVertex3fv(v7);\par
\tab glTexCoord2f(0.0f, 1.0f);\par
\tab glVertex3fv(v6);\par
\tab glTexCoord2f(0.0f, 0.0f);\par
\tab glVertex3fv(v1);\par
\tab glTexCoord2f(1.0f, 0.0f);\par
\par
\tab // top face ===================\par
\tab glVertex3fv(v6);\par
\tab glTexCoord2f(0.0f, 0.0f);\par
\tab glVertex3fv(v5);\par
\tab glTexCoord2f(1.0f, 0.0f);\par
\tab glVertex3fv(v0);\par
\tab glTexCoord2f(1.0f, 1.0f);\par
\par
\tab glVertex3fv(v0);\par
\tab glTexCoord2f(1.0f, 1.0f);\par
\tab glVertex3fv(v1);\par
\tab glTexCoord2f(0.0f, 1.0f);\par
\tab glVertex3fv(v6);\par
\tab glTexCoord2f(0.0f, 0.0f);\par
\par
\tab // bottom face ================\par
\tab glVertex3fv(v2);\par
\tab glTexCoord2f(0.0f, 0.0f);\par
\tab glVertex3fv(v3);\par
\tab glTexCoord2f(1.0f, 0.0f);\par
\tab glVertex3fv(v4);\par
\tab glTexCoord2f(1.0f, 1.0f);\par
\par
\tab glVertex3fv(v4);\par
\tab glTexCoord2f(1.0f, 1.0f);\par
\tab glVertex3fv(v7);\par
\tab glTexCoord2f(1.0f, 0.0f);\par
\tab glVertex3fv(v2);\par
\tab glTexCoord2f(0.0f, 0.0f);\par
\par
\tab glEnd();\par
\tab\par
\tab glBindTexture(GL_TEXTURE_2D, 0);\par
\par
\tab return update_status::UPDATE_CONTINUE;\par
\}\par
\par
// PostUpdate present buffer to screen\par
update_status ModuleRenderer3D::PostUpdate(float dt)\par
\{\par
\tab //Rendering Geometry\par
\tab App->geometry->Draw();\par
\par
\tab DisableGLRenderFlags();\tab\par
\par
\tab // Rendering GUI\par
\tab App->imgui->RenderUI();\par
\par
\tab EnableGLRenderFlags();\par
\par
\tab SDL_GL_SwapWindow(App->window->window);\par
\par
\tab return UPDATE_CONTINUE;\par
\}\par
\par
// Called before quitting\par
bool ModuleRenderer3D::CleanUp()\par
\{\par
\tab LOG("Destroying 3D Renderer");\par
\par
\tab SDL_GL_DeleteContext(context);\par
\par
\tab return true;\par
\}\par
\par
void ModuleRenderer3D::BlitConfigInfo()\par
\{\par
\tab ImGui::Text("GLew Version: ");\par
\tab ImGui::SameLine();\par
\tab ImGui::TextColored(ImVec4(1.0f, 0.64f, 0.0f, 1.0f), "%s", glewGetString(GLEW_VERSION));\par
\tab ImGui::Separator();\par
\par
\tab //Vsync check box\par
\tab if (ImGui::Checkbox("VSync", &vsync))\par
\tab\{\par
\tab\tab if(vsync)\par
\tab\tab\{\par
\tab\tab\tab if (SDL_GL_SetSwapInterval(1) < 0)\par
\tab\tab\tab\{\par
\tab\tab\tab\tab LOG("[error] Unable to set VSync! SDL Error: %s\\n", SDL_GetError());\par
\tab\tab\tab\}\par
\tab\tab\}\par
\tab\tab else SDL_GL_SetSwapInterval(0);\par
\tab\tab App->audio->PlayFxForInput(CHECKBOX_FX);\par
\tab\}\par
\tab ImGui::SameLine(); ImGui::MyShowHelpMarker("(?)", "Turn ON/OFF VSync.");\par
\tab\par
\tab //Depth Test check box\par
\tab if (ImGui::Checkbox("Depht Test", &depth_test))\par
\tab\{\par
\tab\tab App->audio->PlayFxForInput(CHECKBOX_FX);\par
\par
\tab\tab if (depth_test)\par
\tab\tab\{\par
\tab\tab\tab glEnable(GL_DEPTH_TEST);\par
\tab\tab\}\par
\tab\tab else\par
\tab\tab\{\par
\tab\tab\tab glDisable(GL_DEPTH_TEST);\par
\tab\tab\}\par
\tab\}\par
\tab ImGui::SameLine(); ImGui::MyShowHelpMarker("(?)", "Turn ON/OFF the depth pixel painting.");\par
\par
\tab //Cull Test check box\par
\tab if (ImGui::Checkbox("Cull Test", &cull_face))\par
\tab\{\par
\tab\tab App->audio->PlayFxForInput(CHECKBOX_FX);\par
\tab\tab if (cull_face)\par
\tab\tab\{\par
\tab\tab\tab glEnable(GL_CULL_FACE);\par
\tab\tab\}\par
\tab\tab else\par
\tab\tab\{\par
\tab\tab\tab glDisable(GL_CULL_FACE);\par
\tab\tab\}\par
\tab\}\par
\tab ImGui::SameLine(); ImGui::MyShowHelpMarker("(?)", "Turn ON/OFF the triangle culling.");\par
\par
\tab //Texture 2D check box\par
\tab if (ImGui::Checkbox("Texture 2D", &texture_2d))\par
\tab\{\par
\tab\tab App->audio->PlayFxForInput(CHECKBOX_FX);\par
\tab\tab if (texture_2d)\par
\tab\tab\{\par
\tab\tab\tab glEnable(GL_TEXTURE_2D);\par
\tab\tab\}\par
\tab\tab else\par
\tab\tab\{\par
\tab\tab\tab glDisable(GL_TEXTURE_2D);\par
\tab\tab\}\par
\tab\}\par
\tab ImGui::SameLine(); ImGui::MyShowHelpMarker("(?)", "Allows to texture in 2D");\par
\par
\tab //Dither check box\par
\tab if (ImGui::Checkbox("Dither", &dither))\par
\tab\{\par
\tab\tab App->audio->PlayFxForInput(CHECKBOX_FX);\par
\tab\tab if (dither)\par
\tab\tab\{\par
\tab\tab\tab glEnable(GL_DITHER);\par
\tab\tab\}\par
\tab\tab else\par
\tab\tab\{\par
\tab\tab\tab glDisable(GL_DITHER);\par
\tab\tab\}\par
\tab\}\par
\tab ImGui::SameLine(); ImGui::MyShowHelpMarker("(?)", "Dither color components before they are written to the color buffer.");\par
\tab ImGui::Separator();\par
\par
\par
\tab //Lighting data ---------\par
\tab if (ImGui::Checkbox("Lighting", &lighting))\par
\tab\{\par
\tab\tab App->audio->PlayFxForInput(CHECKBOX_FX);\par
\tab\tab if (lighting)\par
\tab\tab\{\par
\tab\tab\tab glEnable(GL_LIGHTING);\par
\tab\tab\}\par
\tab\tab else\par
\tab\tab\{\par
\tab\tab\tab glDisable(GL_LIGHTING);\par
\tab\tab\}\par
\par
\tab\}\par
\tab ImGui::SameLine(); ImGui::MyShowHelpMarker("(?)", "Turn ON/OFF the lights");\par
\tab if (lighting)\par
\tab\{\par
\tab\tab if (ImGui::DragFloat4("Lighting Color", lighting_color, 0.05, 0.0, 1.0, "%.2f"))\par
\tab\tab\{\par
\tab\tab\tab GLfloat LightModelAmbient[] = \{ lighting_color[0], lighting_color[1], lighting_color[2],lighting_color[3] \};\par
\tab\tab\tab glLightModelfv(GL_LIGHT_MODEL_AMBIENT, LightModelAmbient);\par
\tab\tab\}\par
\tab\}\par
\tab // ----------------------\par
\par
\tab ImGui::Separator();\par
\tab\par
\tab //Material Data ---------\par
\tab if (ImGui::Checkbox("Color Material", &material_color))\par
\tab\{\par
\tab\tab App->audio->PlayFxForInput(CHECKBOX_FX);\par
\tab\tab if (material_color)\par
\tab\tab\{\par
\tab\tab\tab glEnable(GL_COLOR_MATERIAL);\par
\tab\tab\}\par
\tab\tab else\par
\tab\tab\{\par
\tab\tab\tab glDisable(GL_COLOR_MATERIAL);\par
\tab\tab\}\par
\tab\}\par
\tab ImGui::SameLine(); ImGui::MyShowHelpMarker("(?)", "Allows to have one or more material parameters tracking the current color");\par
\tab if (material_color)\par
\tab\{\par
\tab\tab if (ImGui::DragFloat4("Material Ambient", material_ambient, 0.05, 0.0, 1.0, "%.2f"))\par
\tab\tab\{\par
\tab\tab\tab GLfloat m_ambient[] = \{ material_ambient[0], material_ambient[1], material_ambient[2], material_ambient[3] \};\par
\tab\tab\tab glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, m_ambient);\par
\tab\tab\}\par
\tab\tab if (ImGui::DragFloat4("Material Diffuse", material_diffuse, 0.05, 0.0, 1.0, "%.2f"))\par
\tab\tab\{\par
\tab\tab\tab GLfloat m_diffuse[] = \{ material_diffuse[0], material_diffuse[1], material_diffuse[2], material_diffuse[3] \};\par
\tab\tab\tab glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, m_diffuse);\par
\tab\tab\}\par
\tab\}\par
\tab // ----------------------\par
\par
\tab ImGui::Separator();\par
\par
\tab //Fog Data --------------\par
\tab if (ImGui::Checkbox("Fog", &fog))\par
\tab\{\par
\tab\tab App->audio->PlayFxForInput(CHECKBOX_FX);\par
\tab\tab if (fog)\par
\tab\tab\{\par
\tab\tab\tab glEnable(GL_FOG);\par
\tab\tab\tab glFogf(GL_FOG_DENSITY, fog_density);\par
\tab\tab\}\par
\tab\tab else\par
\tab\tab\{\par
\tab\tab\tab glDisable(GL_FOG);\par
\tab\tab\}\par
\tab\}\par
\tab ImGui::SameLine(); ImGui::MyShowHelpMarker("(?)", "Turns ON/OFF the Fog");\par
\par
\tab if (fog)\par
\tab\{\par
\tab\tab if (ImGui::DragFloat4("Fog Color", fog_color, 0.05, 0.0, 1.0, "%.2f"))\par
\tab\tab\{\par
\tab\tab\tab GLfloat color[] = \{ fog_color[0], fog_color[1], fog_color[2], fog_color[3] \};\par
\tab\tab\tab glFogfv(GL_FOG_COLOR, color);\par
\tab\tab\}\par
\tab\tab if (ImGui::SliderFloat("Density", &fog_density, 0.0f, 1.0f))\par
\tab\tab\{\par
\tab\tab\tab App->audio->PlayFxForInput(SLICE_TICK_FX);\par
\tab\tab\tab glFogf(GL_FOG_DENSITY, fog_density);\par
\tab\tab\}\par
\tab\}\par
\tab // ----------------------\par
\par
\tab ImGui::Separator();\par
\par
\tab //Wireframe -------------\par
\par
\tab if (ImGui::Checkbox("WireFrame", &wireframe));\par
\tab ImGui::SameLine(); ImGui::MyShowHelpMarker("(?)", "Turns ON/OFF the WireFrame mode");\par
\par
\tab if (wireframe)\par
\tab\{\par
\tab\tab if (ImGui::Checkbox("Front Mode", &front_wireframe));\par
\tab\}\par
\tab\par
\par
\tab //-----------------------\par
\par
\tab ImGui::Separator();\par
\par
\tab //Clear Data ------------\par
\tab if(ImGui::Checkbox("Custom Clear", &custom_clear))\par
\tab\{\par
\tab\tab App->audio->PlayFxForInput(SLICE_TICK_FX);\par
\tab\tab if (!custom_clear)\par
\tab\tab\{\par
\tab\tab\tab glClearColor(0.0f, 0.0f, 0.0f, 0.0f);\par
\tab\tab\tab glClearDepth(1.0f);\par
\tab\tab\}\par
\tab\tab else\par
\tab\tab\{\par
\tab\tab\tab glClearColor(clear_color[0], clear_color[1], clear_color[2], clear_color[3]);\par
\tab\tab\tab glClearDepth(clear_depth);\par
\tab\tab\}\par
\tab\}\par
\tab ImGui::SameLine(); ImGui::MyShowHelpMarker("(?)", "Specify the red, green, blue, and alpha values used when the color buffers are cleared");\par
\tab if (custom_clear)\par
\tab\{\par
\tab\tab if (ImGui::DragFloat4("Clear Color", clear_color, 0.05, 0.0, 1.0, "%.2f"))\par
\tab\tab\{\par
\tab\tab\tab glClearColor(clear_color[0], clear_color[1], clear_color[2], clear_color[3]);\par
\tab\tab\}\par
\tab\tab if (ImGui::DragFloat("Clear Depth", &clear_depth, 0.05, 0.0, 1.0, "%.2f"))\par
\tab\tab\{\par
\tab\tab\tab glClearDepth(clear_depth);\par
\tab\tab\}\par
\tab\}\par
\tab // ----------------------\par
\}\par
\par
void ModuleRenderer3D::SaveConfigInfo(JSON_Object * data_root)\par
\{\par
\tab json_object_set_boolean(data_root, "vsync", vsync);\par
\tab json_object_set_boolean(data_root, "depth_test", depth_test);\par
\tab json_object_set_boolean(data_root, "cull_face", cull_face);\par
\tab json_object_set_boolean(data_root, "texture_2d", texture_2d);\par
\tab json_object_set_boolean(data_root, "dither", dither);\par
\tab // Lighting data\par
\tab json_object_set_boolean(data_root, "lighting", lighting);\par
\tab json_array_t*_array = json_object_get_array(data_root, "lighting_color");\par
\tab json_array_replace_number(_array, 0, lighting_color[0]);\par
\tab json_array_replace_number(_array, 1, lighting_color[1]);\par
\tab json_array_replace_number(_array, 2, lighting_color[2]);\par
\tab json_array_replace_number(_array, 3, lighting_color[3]);\par
\tab // Material data\par
\tab json_object_set_boolean(data_root, "material_color", material_color);\par
\tab _array = json_object_get_array(data_root, "material_ambient");\par
\tab json_array_replace_number(_array, 0, material_ambient[0]);\par
\tab json_array_replace_number(_array, 1, material_ambient[1]);\par
\tab json_array_replace_number(_array, 2, material_ambient[2]);\par
\tab json_array_replace_number(_array, 3, material_ambient[3]);\par
\tab _array = json_object_get_array(data_root, "material_diffuse");\par
\tab json_array_replace_number(_array, 0, material_diffuse[0]);\par
\tab json_array_replace_number(_array, 1, material_diffuse[1]);\par
\tab json_array_replace_number(_array, 2, material_diffuse[2]);\par
\tab json_array_replace_number(_array, 3, material_diffuse[3]);\par
\tab //Wireframe data\par
\tab json_object_set_boolean(data_root, "wireframe", wireframe);\par
\tab json_object_set_boolean(data_root, "front_wireframe", front_wireframe);\par
\par
\tab //Fog data\par
\tab json_object_set_boolean(data_root, "fog", fog);\par
\tab json_object_set_number(data_root, "fog_density", fog_density);\par
\tab _array = json_object_get_array(data_root, "fog_color");\par
\tab json_array_replace_number(_array, 0, fog_color[0]);\par
\tab json_array_replace_number(_array, 1, fog_color[1]);\par
\tab json_array_replace_number(_array, 2, fog_color[2]);\par
\tab json_array_replace_number(_array, 3, fog_color[3]);\par
\tab //Clear data\par
\tab json_object_set_boolean(data_root, "custom_clear", custom_clear);\par
\tab _array = json_object_get_array(data_root, "clear_color");\par
\tab json_array_replace_number(_array, 0, clear_color[0]);\par
\tab json_array_replace_number(_array, 1, clear_color[1]);\par
\tab json_array_replace_number(_array, 2, clear_color[2]);\par
\tab json_array_replace_number(_array, 3, clear_color[3]);\par
\tab json_object_set_number(data_root, "clear_depth", clear_depth);\par
\}\par
\par
// Functionality ================================\par
void ModuleRenderer3D::OnResize(int width, int height)\par
\{\par
\tab glViewport(0, 0, width, height);\par
\par
\tab glMatrixMode(GL_PROJECTION);\par
\tab glLoadIdentity();\par
\tab ProjectionMatrix = perspective(60.0f, (float)width / (float)height, 0.125f, 512.0f);\par
\tab glLoadMatrixf(&ProjectionMatrix);\par
\par
\tab glMatrixMode(GL_MODELVIEW);\par
\tab glLoadIdentity();\par
\}\par
\par
bool ModuleRenderer3D::GetWireframe() const\par
\{\par
\tab return wireframe;\par
\}\par
\par
bool ModuleRenderer3D::GetWireframeFront() const\par
\{\par
\tab return front_wireframe;\par
\}\par
\par
void ModuleRenderer3D::DisableGLRenderFlags()\par
\{\par
\tab glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);\par
\tab glDisable(GL_LIGHTING);\par
\}\par
\par
void ModuleRenderer3D::EnableGLRenderFlags()\par
\{\par
\tab if (lighting)glEnable(GL_LIGHTING);\par
\}\par
}
 